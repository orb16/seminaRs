---
title: 'Seminar 7: multivariate'
author: "Jon Bray/Olivia Burge"
date: "23 September 2014"
output: html_document
---

# Multivariate data - introduction
We can put a bunch of stuff here on why on earth one ends up with multiple responses, multiple predictors and decide it's a good idea to put it into R.  

A common workflow with multivariate data is:

1. Visualise it (plotting)
2. Basic ordination (more on this later)
3. Run more detailed multivariate analyses and ordinations
4. Plot the results and write up

You may remember doing something like this in undergrad:
```{r, include=FALSE}
# loading and/or installing the required packages 
if(!require(vegan)){
  install.packages("vegan", repos = 'http://cran.stat.auckland.ac.nz/')
  library(vegan)
}
if(!require(ggplot2)){
    install.packages("ggplot2", repos = 'http://cran.stat.auckland.ac.nz/')
    library(ggplot2)
}
if(!require(grid)){
  install.packages("grid", repos = 'http://cran.stat.auckland.ac.nz/')
  library(grid)
}
if(!require(RCurl)){
  install.packages("RCurl", repos = 'http://cran.stat.auckland.ac.nz/')
  library(RCurl)
}

url <- getURL("https://raw.githubusercontent.com/orb16/seminaRs/master/allgroups_bothsites_transposed_env2.csv", ssl.verifypeer = FALSE)
kowai.lords.data <- read.csv(text= url, header = TRUE, row.names = 1)
head(kowai.lords.data)
set.seed(201)

#kowai.lords.data <- read.csv("/Users/Liv/Dropbox/Biol270/allgroups_bothsites_transposed_env2.csv")

#NMDS
kowai.lords.NMDS <- metaMDS(kowai.lords.data[ , 4:32])

#envfit
kowai.lords.envfit<-envfit(kowai.lords.NMDS, env = kowai.lords.data[ , 1:3], perm = 999) #env is the environmental data, subsetted by column

#adding in points
kowai.lords.data$NMDS1 <- kowai.lords.NMDS$points[ ,1]
kowai.lords.data$NMDS2 <- kowai.lords.NMDS$points[ ,2]

#creating dataframe of envfit vectors
env.scores.KL <- as.data.frame(scores(kowai.lords.envfit, display = "vectors"))
env.scores.KL <- cbind(env.scores.KL, env.variables = rownames(env.scores.KL))

#creating dataframe for ellipses
#function - need to run this for the ellipse (it is called later)
veganCovEllipse<-function (cov, center = c(0, 0), scale = 1, npoints = 100) 
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}

# data for the ellipse - needs to be run after the function above
# in this case uses "Site" - replace. And sdd. Only need sdd if (as in this case) you want to exclude a level of the factor (here, the Kowai flat - not enough reps. Otherwise just use the general dataframe which you've added the points to. here kowai.lords.data)
sdd<-subset(kowai.lords.data, kowai.lords.data$Site %in% c("Kowai", "Lords"))
sdd$Site<-factor(sdd$Site)

df_ell.KL <- data.frame()
for(g in levels(sdd$Site)){
  df_ell.KL <- rbind(df_ell.KL, cbind(as.data.frame(with(sdd [sdd$Site==g,],
                                                         veganCovEllipse(cov.wt(cbind(NMDS1,NMDS2),wt=rep(1/length(NMDS1),length(NMDS1)))$cov,center=c(mean(NMDS1),mean(NMDS2)))))
                                      ,Site=g))
}

mult<-1.55

KL <- ggplot(data = kowai.lords.data, aes(y=NMDS2, x=NMDS1))+
   geom_path(data = df_ell.KL, aes(x=NMDS1, y=NMDS2, group=Site, alpha=Site))+
   labs(linetype="Site Centroids")+
   scale_alpha_manual("Site", values=c(0.45,0.89))+
   geom_point(aes(alpha = Site), size = 3) +
   geom_segment(data = env.scores.KL,
              aes(x = 0, xend = mult*NMDS1, y = 0, yend = mult*NMDS2),
                arrow = arrow(length = unit(0.25, "cm")), colour = "grey50") +
   geom_text(data=env.scores.KL,
             aes(x = (mult + mult/10) * NMDS1,
                 y = (mult + mult/10) * NMDS2,
                 label=env.variables),
             size=5,
             hjust=1)+
   scale_shape_manual(values = c(1,19))+
   coord_cartesian(ylim = c(-0.7,0.7), xlim = c(-1.5, 1.5))+
  theme_bw() +
   theme(legend.position = c(1,1),
         legend.justification = c(1,1),
         legend.key = element_blank(),
         legend.background = element_rect(colour = "grey"))
````
````{r, echo = FALSE}
KL
````

# Ordination methods

[Something about constrained vs unconstrained]

## Unconstrained: NMDS and the rest

Before we start our analysis, we need to examine the data.  Often we might histogram out all the species to what they are doing, and do some 

```{r data}
#data - from the vegan package:
#see ?mite for an explanation of what it is
data(mite)
head(mite[, 1:11], 3) #shows us first 3 lines of first 11 columns
data(mite.env)
head(mite.env, 3) #first three lines
````

We might also want to do a quick visualisation of the data.  Here we leave out Substrate because it's a bit slow. 

```{r, include = FALSE}
#GGally has the ggpairs function in 
if(!require(GGally)){
  install.packages("GGally", repos = 'http://cran.stat.auckland.ac.nz/')
  library(GGally)
  }
theme_set(theme_bw())
````
```{r}
ggpairs(mite.env[c(1:2,4:5)], colour = "Shrub") # yes the colours are atrocious.
```
```{r, eval =FALSE}
# alternatively, use the base version - faster - we can include Substrate, but less user  friendlly
pairs(mite.env)
```

### NMDS

```{r, results='hide'}
set.seed(505) #set seed for reproducibility. 
meta.nmds.mite <- metaMDS(mite) #no transformation of species data is made here 
# prior to bray curtis dissimilarities being calculated. 
#(Bray Curtis is the default in R).
meta.nmds.mite #prints very basic dsecription
```
```{r}
stressplot(meta.nmds.mite) # To gain the stress plot for stress values for your NMDS 
```
```{r, include=FALSE}
#plotting ####
#data for NMDS points
mite.NMDS.data <- mite.env #there are other ways of doing this. But this is the way I do it for ease of plotting
mite.NMDS.data$NMDS1 <- meta.nmds.mite$points[ ,1] #this puts the NMDS scores for the plots into a new dataframe. you could put them into an existing one if you preferred.
mite.NMDS.data$NMDS2 <- meta.nmds.mite$points[ ,2]

# species data - this is for only having the most common species labelled
stems <- colSums(mite) #total abundances for each species
spps <- data.frame(scores(meta.nmds.mite, display = "species")) 
#dataframe of species scores for plotting
spps$species <- row.names(spps) # making a column with species names
spps$colsums <- stems #adding the colSums from above
spps <- spps[!is.na(spps$NMDS1) & !is.na(spps$NMDS2),] #removes NAs
spps.colmedian <- median(spps$colsums) #create an object that is the median of the abundance of the measured species
spps.colmean <- mean(spps$colsums) #creates a mean instead if you wish to use
spps2 <- subset(spps, spps$colsums > spps.colmedian) #select the most abundant species. Could discard fewer by going something like - spps$colsums>(spps.colmedian/2) instead
spps2$species <- factor(spps2$species) #otherwise factor doesn't drop unused levels and it will throw an error

plot_mite_1 <- ggplot(data = mite.NMDS.data, aes(y = NMDS2, x = NMDS1)) +
   geom_point(aes(shape = Topo), size = 3) + #puts the site points in from the ordination, shape determined by site, size refers to size of point
   # geom_text(data=spps2, aes(x=spps2$NMDS1, y=spps2$NMDS2, label=species), size = 3.3, hjust=1.1)+ #labelling the species. hjust used to shift them slightly from their points
  geom_text(data = spps2, aes(x = spps2$NMDS1, y = spps2$NMDS2, label=species), 
            size = 3, 
            hjust = 1.1)+ #labelling the species. hjust used to shift them slightly from their points
  coord_cartesian(x = c(-1.5, 1.5))+ 
  scale_shape_manual("Topo Type",  values = c(1,16)) + #sets the name of the legend for shape, and says which symbols we want (equivalent to the pch command in plot)
   theme_bw()+
   theme(legend.position = "bottom", 
         legend.key = element_blank(),
         legend.background = element_rect(colour = "grey"))
````
Once we've run the NMDS, we can plot the sites and their species in a plot.  Here we've coloured them by topo type out of interest.

```{r, echo = FALSE}
plot_mite_1
```

### Effect of environment on composition (envfit)
We may also wish to see how environmental variables we've measured at each plot correlate with the species composition at each plot.  Envfit runs a correlation:

```{r}
mite.envfit <- envfit(meta.nmds.mite, env = mite.env, perm = 999) #standard envfit
mite.envfit
```

We see that the two continuous variables, substrate density ("SubsDens") and water content ("WatrCont") have significant effects, particulary water content (r-squared of 0.7).  The factors - substrate, shrub, and topo are all significant as well.

We can plot the continuous variables as vectors on the ordination:

```{r, include = FALSE}
#ends <- sqrt(mite.envfit$vectors$r) * mite.envfit$vectors$arrows
#ends <- ends * vegan:::ordiArrowMul(ends, c(0,0))

env.scores.mite <- as.data.frame(scores(mite.envfit, display = "vectors")) #extracts relevant scores from envifit
env.scores.mite <- cbind(env.scores.mite, env.variables = rownames(env.scores.mite)) #and then gives them their names
mult<-vegan:::ordiArrowMul(scores(mite.envfit, display="vectors"))

env.scores.mite$NMDS1_scaled <- mult * env.scores.mite$NMDS1
env.scores.mite$NMDS2_scaled <- mult * env.scores.mite$NMDS2

````
```{r, echo = FALSE}
plot_mite_2 <- ggplot(data = mite.NMDS.data, aes(y = NMDS2, x = NMDS1)) +
    coord_cartesian(x = c(-1.5, 1.5))+ 
   geom_point(aes(shape = Topo), size = 3) + #puts the site points in from the ordination, 
  geom_text(data = spps2, aes(x = spps2$NMDS1, y = spps2$NMDS2, label=species), 
            size = 3, 
            hjust = 1.1)+ #labelling the species. hjust used to shift them slightly from their points
  geom_segment(data = env.scores.mite,
               aes(x = 0, xend = NMDS1_scaled , y = 0, yend = NMDS2_scaled ),
               arrow = arrow(length = unit(0.25, "cm")), colour = "grey") + 
  geom_text(data = env.scores.mite, 
            aes(x = 1.05 * NMDS1_scaled , y = 1.05 * NMDS2_scaled, label=env.variables),
            size = 5)+
  scale_shape_manual("Topo Type",  values = c(1,16)) + #sets the name of the legend for shape, and says which symbols we want (equivalent to the pch command in plot)
   theme_bw()+
   theme(legend.position = "bottom", 
         legend.key = element_blank(),
         legend.background = element_rect(colour = "grey"))
plot_mite_2
```

### Non-linear environmental effects (ordisurf)

Environmental effects aren't always linear though.  We can check for this by using the ordisurf function in vegan (which is even recommended in the envfit() help!):
```{r, include = FALSE}
if(!require(mgcv)){
  install.packages("mgcv", repos = 'http://cran.stat.auckland.ac.nz/')
  library(mgcv)}
```


```{r, results = FALSE, fig.keep='none'}
# we use the function ordisurf to look at the relationship to one of the variables with the biggest influence
ordi.mite <- ordisurf(meta.nmds.mite ~ mite.env$SubsDens) #created the ordisurf object
```
We can also plot in ggplot2 (lots of extra code hidden):

```{r, include = FALSE}
# Ordisurf plotting - extracting data ####
ordi.grid <- ordi.mite$grid #extracts the ordisurf object
str(ordi.grid) #it's a list though - cannot be plotted as is
ordi.mite2 <- expand.grid(x = ordi.grid$x, y = ordi.grid$y) #get x and ys
ordi.mite2$z <- as.vector(ordi.grid$z) #unravel the matrix for the z scores
ordi.mite.na <- data.frame(na.omit(ordi.mite2)) #gets rid of the nas
ordi.mite.na #looks ready for plotting!


## Plotting ordisurf in ggplot2 ####
plot_mite_3 <-ggplot(mite.NMDS.data, aes(x = NMDS1, y = NMDS2))+
  stat_contour(data = ordi.mite.na, aes(x = x, y = y, z = z, colour = rev(..level..)),
               binwidth = 2)+ #can change the binwidth depending on how many contours you want
  labs(colour = "Substrate Density")+ #another way to set the labels, in this case, for the colour legend
  scale_colour_gradient(high = "darkgreen", low = "darkolivegreen1")+ #here we set the high and low of the colour scale.  Can delete to go back to the standard blue, or specify others
  geom_point(size = 3, alpha = 0.8,  aes(shape = Topo)) + #plots the NMDS points, with shape by topo type
  theme_bw() + #for aesthetics
  scale_shape_manual("Topo Type",  values = c(1,16)) + #sets the name of the legend for shape, and says which symbols we want (equivalent to the pch command in plot)
  theme(legend.key = element_blank(),  #removes the box around each legend item
        legend.position = "bottom", #legend at the bottom
        legend.direction = "horizontal",
        legend.box = "horizontal",
        legend.box.just = "centre")
```
```{r, echo = FALSE}
plot_mite_3
```

### Multivariate anova (permanova/adonis)
[Some smart text about the difference between adonis and envfit. I have some basic stuff somewhere]

```{r}
#scaling env variables
mite.env$SubsDens_scaled <- scale(mite.env$SubsDens) #scaling the variables
mite.env$WatrCont_scaled <- scale(mite.env$WatrCont)

#running the permanova
adonis.mite <- adonis(formula = mite ~ SubsDens_scaled + WatrCont_scaled + Substrate + Shrub + Topo, 
                      data = mite.env, 
                      method = "bray")
adonis.mite

```
We can plot the results of this - for example, we may wish to see how the closely our plots are when divided on shrub type (our ordinal factor):

```{r, include = FALSE}
# Let's visualise the effect of substrate by plotting the 95% CIs

# function for ellipsess - just run this, is used later ####
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100) 
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}

#data for ellipse, in this case using the management factor
df_ell.mite.Shrub <- data.frame() #sets up a data frame before running the function.
for(g in levels(mite.NMDS.data$Shrub)){
  df_ell.mite.Shrub <- rbind(df_ell.mite.Shrub, 
                                 cbind(as.data.frame(with(mite.NMDS.data[mite.NMDS.data$Shrub==g,], 
                                                          veganCovEllipse(cov.wt(cbind(NMDS1,NMDS2),
                                                                                 wt=rep(1/length(NMDS1),
                                                                                        length(NMDS1)))$cov,center=c(mean(NMDS1),mean(NMDS2))))), Shrub=g))
}

# data for labelling the ellipse
NMDS.mean.mite = aggregate(mite.NMDS.data[ ,c("NMDS1", "NMDS2")], 
                         list(group = mite.NMDS.data$Shrub), mean)

threecolour <- c("cornflowerblue","royalblue", "darkblue") #easier to change colours than each time in the plot

plot_mite_4 <-ggplot(mite.NMDS.data, aes(x = NMDS1, y = NMDS2))+
  geom_path(data = df_ell.mite.Shrub, aes(x = NMDS1, y = NMDS2, group = Shrub, linetype = Shrub))+ #this is the ellipse, seperate ones by Site. If you didn't change the "alpha" (the shade) then you need to keep the "group 
  geom_point(aes(shape = Shrub, colour = Shrub), size = 3) + #puts the site points in from the ordination, shape determined by site, size refers to size of point
  scale_colour_manual(values = threecolour)+
  scale_linetype_manual(values = c("solid", "dotted", "longdash"))+
  geom_text(data = NMDS.mean.mite, aes(x = NMDS1, 
                                       y = NMDS2, 
                                       label = group)) + 
  theme_bw() + #for aesthetics
  theme(legend.key = element_blank(),  #removes the box around each legend item
        legend.position = c(0,0), 
        legend.justification = c(0,0),
        legend.background = element_rect(colour = "grey"))
```
```{r, echo = FALSE}
plot_mite_4
```

### Are the groups different, or is their variance different? (betadisper)

### Whatever anosim is (anosim)


## Constrained

### How much variance do the variables explain? (RDA, varpart)

### Something about stepwise

### Incorporating distance: dbRDA
